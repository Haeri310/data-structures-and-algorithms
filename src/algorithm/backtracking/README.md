# 백트래킹 (Backtracking)


## ✅ 상황
- 경우의 수를 구하는 문제로, 완전탐색이라 볼 수 있다
- N-Queen 문제를 생각해보면 편한데, 체스판에 퀸을 __'두었다가'__ __'뺐다가'__ 탐색하며, 문제가 요구하는 조건을 충족시키는지 확인한다


## ✅ 시간복잡도 O(N!)
- 모든 상황을 체크하기에 시간복잡도가 매우 크며 문제마다 다르겠지만 대략 N! 를 갖는다
- 높은 시간복잡도이기에 N 이 10 미만으로 주어졌다면 빽트래킹으로 풀어버리는 걸 떠올려 보자
- 13! = 6_227_020_800, 12! = 479_001_600, 11! = 39_916_800, 10! = 3_628_800 (이론상 11까지는 가능하지만, 문제마다 약간씩 시간이 더 걸리기에 주로 10 미만으로 나온다)


## ✅ 의사코드
```
void backtracking(int line) {
  //검증
  if (검증하여 조건을 만족하는지 체크) -> 정답 처리 후 return;
  if (line == N) -> return;

  //경우의 수 두기
  for (int i=0; i<N; i++) {
    if (조건을 만족하는 상황이 아니라면) -> continue;

    map[line][i] = 1; //경우의 수 설치
    backtracking(line + 1); // 재귀
    map[line][i] = 0; //경우의 수 해체
  }
}
```
- 하나의 map 에서 설치했다가 해제했다가 하는 것이지, 절대로 재귀함수마다 map 을 새로 생성해서는 안 된다
- 경우의 수가 굉장히 크기에, map 을 그렇게 생성했다가는 __메모리초과__ 된다
